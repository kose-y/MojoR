% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roxygen_api_docs.R
\name{mojor_build}
\alias{mojor_build}
\title{Build a Callable MÃ¶joR Kernel}
\usage{
mojor_build(
fn,
...,
name = "mojor_kernel",
build_dir = tempdir(),
load = TRUE,
verbose = FALSE,
cache = TRUE,
cache_dir = NULL,
na_mode = NULL,
fusion_debug = FALSE,
assume_aligned = NULL,
simd_mode = NULL,
elementwise = FALSE,
elementwise_target = c("cpu", "gpu"),
elementwise_size = NULL,
elementwise_cpu = NULL,
elementwise_gpu_layouttensor = NULL,
gpu_jit_mode = NULL,
broadcast = c(
"none",
"scalar",
"recycle",
"recycle_warn",
"broadcast_nd",
"broadcast_nd_warn"
),
fast_math = NULL,
parallel = FALSE,
semantics = c("r", "raw"),
unroll = NULL,
reduction = NULL,
bounds_check = NULL,
index_base = NULL,
array_layout = NULL,
tile = NULL,
opt_level = NULL,
r_jit_level = NULL,
debug = FALSE,
trace = FALSE,
memory_check = FALSE,
profile = FALSE,
error_mode = c("stop", "partial", "retry"),
max_retries = 3,
retry_delay = 0.1,
object_mode = c("off", "fallback", "hybrid"),
df_schema = NULL
)
}
\arguments{
\item{fn}{Function to transpile and compile.}

\item{...}{Named type annotations for arguments, e.g. \code{x = "f64[]"}, \code{n = "i32"}.
Vectors, matrices, and higher-dimensional arrays are all ndarrays distinguished
by rank: \code{"f64[]"} (or \code{"f64[1d]"}) for 1-D, \code{"f64[,]"} (or \code{"f64[2d]"}) for 2-D,
\code{"f64[3d]"} for 3-D, etc.}

\item{name}{Kernel symbol name used in generated Mojo/C ABI glue.}

\item{na_mode}{NA policy override. \code{NULL} uses \code{mojor_options("na_mode")}.}

\item{fusion_debug}{If \code{TRUE}, emit fusion/SIMD routing diagnostics.}

\item{assume_aligned}{Optional positive integer alignment hint (bytes) for SIMD codegen.}

\item{simd_mode}{SIMD mode override (typically \code{"explicit"} or \code{"auto"}).}

\item{elementwise}{Enable elementwise lowering path when eligible.}

\item{elementwise_target}{Elementwise target, \code{"cpu"} or \code{"gpu"}.}

\item{elementwise_size}{Optional elementwise launch/work size hint.}

\item{elementwise_cpu}{Optional CPU-only elementwise override.}

\item{elementwise_gpu_layouttensor}{Optional GPU elementwise layout-tensor override.}

\item{gpu_jit_mode}{Optional GPU JIT mode override for elementwise GPU routing.}

\item{broadcast}{Broadcast/recycling policy.}

\item{parallel}{Enable parallel routing when legal.}

\item{semantics}{Execution semantics mode: \code{"r"} or \code{"raw"}.}

\item{unroll}{Optional loop-unroll scheduling hint.}

\item{reduction}{Optional reduction scheduling mode.}

\item{bounds_check}{Optional bounds-check policy override.}

\item{index_base}{Optional index base override (\code{"one_based"} or \code{"zero_based"}).}

\item{array_layout}{Optional layout override (\code{"col_major"} or \code{"row_major"}).}

\item{tile}{Optional tiling metadata.}

\item{opt_level}{Optimization level override (\verb{0..3} or \code{NULL}).}

\item{r_jit_level}{R bytecode JIT level (\verb{0..3}) used during transpile; \code{NULL} uses \code{mojor_options("r_jit_level")}.}

\item{debug}{Enable debug-oriented code generation paths.}

\item{trace}{Enable verbose trace diagnostics.}

\item{memory_check}{Enable additional memory safety checks in generated wrapper paths.}

\item{df_schema}{Optional data.frame schema metadata for rewrite paths.}

\item{build_dir}{Directory used for non-cached build artifacts.}

\item{load}{If \code{TRUE}, load compiled wrapper and return callable closures.}

\item{verbose}{If \code{TRUE}, print build commands.}

\item{cache}{If \code{TRUE}, reuse cached build artifacts by content hash.}

\item{cache_dir}{Optional cache root directory.}

\item{fast_math}{Optional fast-math flag toggle/override.}

\item{profile}{Attach profiling wrappers/metadata to results.}

\item{error_mode}{Error handling mode, one of \code{"stop"}, \code{"partial"}, or \code{"retry"}.}

\item{max_retries}{Maximum retries when \code{error_mode = "retry"}.}

\item{retry_delay}{Delay (seconds) between retries for retry mode.}

\item{object_mode}{Object fallback mode: \code{"off"}, \code{"fallback"}, or \code{"hybrid"}.}
}
\value{
A build result list. Common fields:
\itemize{
\item \code{func}: callable R wrapper for compiled kernel (\code{load = TRUE}).
\item \code{gpu_func}, \code{gpu_func_raw}: optional GPU wrappers when emitted.
\item \code{build_dir}: artifact directory.
\item \code{kernel}, \code{cache_key}, \code{wrapper_so}: build identifiers/paths.
\item \code{trans}: transpilation payload from \code{\link[=mojor_transpile]{mojor_transpile()}}.
\item \code{success}: build success flag.
}
}
\description{
Transpile and compile a supported R function into a callable native kernel.
}
\examples{
f <- function(x) {
s <- 0
for (i in 1:length(x)) s <- s + x[i]
s
}

\dontrun{
b <- mojor_build(f, x = "f64[]")
b$func(c(1, 2, 3))
}
}
