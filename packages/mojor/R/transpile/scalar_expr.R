# Transpile scalar expression (Step 1b Step 1)
.mojor_transpile_scalar_expression <- function(expr, args, types, name) {
 # Build expression info
  expr_info <- .mojor_analyze_scalar_expression(expr, args, types)

 # Generate Mojo code
  mojo_code <- .mojor_generate_scalar_expression_kernel(
    name = name,
    expr = expr,
    expr_info = expr_info,
    args = args,
    types = types
  )

 # Return result
  list(
    mojo = mojo_code,
    is_expression_kernel = TRUE,
    return_type = expr_info$return_type,
    args = args,
    types = types
  )
}

# Analyze scalar expression to determine types and operations
.mojor_analyze_scalar_expression <- function(expr, args, types) {
  if (is.name(expr)) {
    arg_name <- as.character(expr)
    if (arg_name %in% args) {
      return(list(
        kind = "var",
        name = arg_name,
        return_type = .mojor_mojo_type_scalar(types[[arg_name]])
      ))
    }
    stop("mojor_transpile: unknown variable: ", arg_name)
  }

  if (is.numeric(expr)) {
    if (is.integer(expr)) {
      return(list(kind = "const", value = expr, return_type = "Int32"))
    } else {
      return(list(kind = "const", value = expr, return_type = "Float64"))
    }
  }

  if (is.call(expr)) {
    op <- as.character(expr[[1]])

 # Check for reduction functions (Step 1b Step 2)
    if (op %in% c("sum", "mean", "min", "max", "prod", "sd", "var")) {
 # Reduction call within expression
      if (length(expr) < 2) {
        stop("mojor_transpile: ", op, "() requires an argument")
      }

      arg_expr <- expr[[2]]
      if (!is.name(arg_expr)) {
        stop("mojor_transpile: reduction argument must be a variable, got: ", deparse(arg_expr))
      }

      arg_name <- as.character(arg_expr)
      if (!(arg_name %in% args)) {
        stop("mojor_transpile: unknown argument: ", arg_name)
      }

      if (!.mojor_is_array(types[[arg_name]])) {
        stop("mojor_transpile: reduction requires array argument, got: ", types[[arg_name]])
      }

      return(list(
        kind = "reduction",
        fn_name = op,
        arg_name = arg_name,
        return_type = "Float64" # All reductions return Float64
      ))
    }

 # Binary operators
    if (op %in% c("+", "-", "*", "/", "^", "%%", "%/%")) {
 # Binary operation
      left_info <- .mojor_analyze_scalar_expression(expr[[2]], args, types)
      right_info <- .mojor_analyze_scalar_expression(expr[[3]], args, types)

 # Type promotion: if either is Float64, result is Float64
      return_type <- if (left_info$return_type == "Float64" || right_info$return_type == "Float64") {
        "Float64"
      } else {
        "Int32"
      }

      return(list(
        kind = "binop",
        op = op,
        left = left_info,
        right = right_info,
        return_type = return_type
      ))
    }
  }

  stop("mojor_transpile: unsupported scalar expression: ", deparse(expr))
}

# Generate Mojo code for scalar expression kernel
.mojor_generate_scalar_expression_kernel <- function(name, expr, expr_info, args, types) {
 # Preamble
  preamble <- c(
    "# Generated by mojor_transpile (expression-only mode - scalar path)",
    "from memory import OpaquePointer, UnsafePointer",
    "comptime ImmutOpaqueAny = OpaquePointer[mut=False, origin=ImmutAnyOrigin]",
    "comptime ImmutFloat64Ptr = UnsafePointer[mut=False, type=Float64, origin=ImmutAnyOrigin]",
    ""
  )

 # Build parameter list
  params <- lapply(args, function(a) {
    spec <- types[[a]]
    if (.mojor_is_array(spec)) {
 # Array parameter: pointer + length
      c(
        paste0("    ", a, "_ptr: ImmutOpaqueAny"),
        paste0("    __mojor_len_", a, ": Int32")
      )
    } else {
 # Scalar parameter
      paste0("    ", a, ": ", .mojor_mojo_type_scalar(spec))
    }
  })
  params <- unlist(params)

 # Function signature
  signature <- paste0(
    "@export(\"", name, "\", ABI=\"C\")\n",
    "fn ", name, "(\n",
    paste(params, collapse = ",\n"),
    "\n) -> ", expr_info$return_type, ":"
  )

 # Generate expression code with reductions
  reduction_code <- .mojor_collect_reductions(expr_info)
  expr_code <- .mojor_emit_scalar_expression(expr_info)

 # Function body
  body_lines <- c()

 # Add reduction computations
  if (length(reduction_code) > 0) {
    body_lines <- c(body_lines, reduction_code)
  }

 # Add return statement
  body_lines <- c(body_lines, paste0("    return ", expr_code))

 # Combine
  paste(c(preamble, signature, body_lines), collapse = "\n")
}

# Collect all reduction computations needed
.mojor_collect_reductions <- function(expr_info, collected = list()) {
  if (expr_info$kind == "reduction") {
 # Generate inline reduction code
    var_name <- paste0("__mojor_", expr_info$fn_name, "_", expr_info$arg_name)
    arg_name <- expr_info$arg_name

    code <- c(
      paste0("    # Compute ", expr_info$fn_name, "(", arg_name, ")"),
      paste0("    var ", arg_name, ": ImmutFloat64Ptr = ", arg_name, "_ptr.bitcast[Float64]()"),
      paste0("    var n_", arg_name, " = Int(__mojor_len_", arg_name, ")")
    )

 # Generate reduction logic based on function
    if (expr_info$fn_name == "sum") {
      code <- c(
        code,
        paste0("    var ", var_name, ": Float64 = 0.0"),
        paste0("    for i in range(n_", arg_name, "):"),
        paste0("        ", var_name, " += ", arg_name, "[i]")
      )
    } else if (expr_info$fn_name == "mean") {
      code <- c(
        code,
        paste0("    var ", var_name, ": Float64 = 0.0"),
        paste0("    for i in range(n_", arg_name, "):"),
        paste0("        ", var_name, " += ", arg_name, "[i]"),
        paste0("    ", var_name, " = ", var_name, " / Float64(n_", arg_name, ")")
      )
    } else if (expr_info$fn_name == "min") {
      code <- c(
        code,
        paste0("    var ", var_name, ": Float64 = ", arg_name, "[0]"),
        paste0("    for i in range(1, n_", arg_name, "):"),
        paste0("        if ", arg_name, "[i] < ", var_name, ":"),
        paste0("            ", var_name, " = ", arg_name, "[i]")
      )
    } else if (expr_info$fn_name == "max") {
      code <- c(
        code,
        paste0("    var ", var_name, ": Float64 = ", arg_name, "[0]"),
        paste0("    for i in range(1, n_", arg_name, "):"),
        paste0("        if ", arg_name, "[i] > ", var_name, ":"),
        paste0("            ", var_name, " = ", arg_name, "[i]")
      )
    } else if (expr_info$fn_name == "prod") {
      code <- c(
        code,
        paste0("    var ", var_name, ": Float64 = 1.0"),
        paste0("    for i in range(n_", arg_name, "):"),
        paste0("        ", var_name, " *= ", arg_name, "[i]")
      )
    }

    code <- c(code, "")
    return(code)
  }

  if (expr_info$kind == "binop") {
 # Recursively collect from left and right
    left_code <- .mojor_collect_reductions(expr_info$left)
    right_code <- .mojor_collect_reductions(expr_info$right)
    return(c(left_code, right_code))
  }

  character(0)
}

# Emit Mojo code for scalar expression
.mojor_emit_scalar_expression <- function(expr_info) {
  if (expr_info$kind == "var") {
    return(expr_info$name)
  }

  if (expr_info$kind == "const") {
    if (expr_info$return_type == "Float64") {
      return(paste0(expr_info$value, ".0"))
    } else {
      return(as.character(expr_info$value))
    }
  }

  if (expr_info$kind == "reduction") {
 # Reference the computed reduction variable
    var_name <- paste0("__mojor_", expr_info$fn_name, "_", expr_info$arg_name)
    return(var_name)
  }

  if (expr_info$kind == "binop") {
    left_code <- .mojor_emit_scalar_expression(expr_info$left)
    right_code <- .mojor_emit_scalar_expression(expr_info$right)

 # Handle type conversion if needed
    if (expr_info$return_type == "Float64") {
      if (expr_info$left$return_type == "Int32") {
        left_code <- paste0("Float64(", left_code, ")")
      }
      if (expr_info$right$return_type == "Int32") {
        right_code <- paste0("Float64(", right_code, ")")
      }
    }

 # Map R operators to Mojo
    mojo_op <- expr_info$op
    if (mojo_op == "^") mojo_op <- "**"
    if (mojo_op == "%/%") mojo_op <- "//" # Integer division

    return(paste0("(", left_code, " ", mojo_op, " ", right_code, ")"))
  }

  stop("mojor_transpile: cannot emit expression: ", expr_info$kind)
}

# Helper: Map R type to Mojo type (scalar types only, for expression-only kernels)
.mojor_mojo_type_scalar <- function(r_type) {
  if (r_type == "f64") {
    return("Float64")
  }
  if (r_type == "i32") {
    return("Int32")
  }
  if (r_type == "lgl") {
    return("Int32")
  } # Logical as Int32
  if (r_type == "f32") {
    return("Float32")
  }
  stop("mojor_transpile: unsupported scalar type: ", r_type)
}

cat("Scalar expression transpiler functions loaded.\n")
