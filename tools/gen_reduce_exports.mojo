from pathlib import Path
from sys import argv

@fieldwise_init
struct DTypeInfo:
    var tag: String
    var dtype: String
    var ptr: String
    var ret: String

fn emit_reduce(buf: String, name: String, dtype: DTypeInfo, reduce_op: String, manual: Bool) -> String:
    var out = buf
    out += "@export(\"" + name + "\", ABI=\"C\")\n"
    out += "fn " + name + "(ptr: ImmutOpaqueAny, n: Int32) -> " + dtype.ret + ":\n"
    out += "    var data: " + dtype.ptr + " = ptr.bitcast[Scalar[" + dtype.dtype + "]]()\n"
    var manual_flag = "False"
    if manual:
        manual_flag = "True"
    out += "    return reduce_nomiss[" + dtype.dtype + "](data, Int(n), " + reduce_op + ", " + manual_flag + ")\n\n"
    return out

fn emit_which(buf: String, name: String, dtype: DTypeInfo, is_min: Bool) -> String:
    var out = buf
    out += "@export(\"" + name + "\", ABI=\"C\")\n"
    out += "fn " + name + "(ptr: ImmutOpaqueAny, n: Int32) -> Int32:\n"
    out += "    var data: " + dtype.ptr + " = ptr.bitcast[Scalar[" + dtype.dtype + "]]()\n"
    var is_min_flag = "False"
    if is_min:
        is_min_flag = "True"
    out += "    return which_nomiss[" + dtype.dtype + "](data, Int(n), " + is_min_flag + ")\n\n"
    return out

fn emit_sdvar(buf: String, name: String, dtype: DTypeInfo, twopass: Bool) -> String:
    var out = buf
    out += "@export(\"" + name + "\", ABI=\"C\")\n"
    out += "fn " + name + "(ptr: ImmutOpaqueAny, n: Int32) -> " + dtype.ret + ":\n"
    out += "    var data: " + dtype.ptr + " = ptr.bitcast[Scalar[" + dtype.dtype + "]]()\n"
    var fn_name = "var_nomiss"
    if twopass:
        fn_name = "var_nomiss_twopass"
    if name.startswith("mojor_sd_"):
        fn_name = "sd_nomiss"
        if twopass:
            fn_name = "sd_nomiss_twopass"
    out += "    return " + fn_name + "[" + dtype.dtype + "](data, Int(n))\n\n"
    return out

fn emit_abs_f64(buf: String) -> String:
    var out = buf
    out += "@export(\"mojor_abs_f64\", ABI=\"C\")\n"
    out += "fn mojor_abs_f64(ptr: MutOpaqueAny, n: Int32) -> None:\n"
    out += "    var data: MutF64Ptr = ptr.bitcast[Scalar[DType.float64]]()\n"
    out += "    var n_i = Int(n)\n"
    out += "    for i in range(n_i):\n"
    out += "        var v = data[i]\n"
    out += "        if v < 0.0:\n"
    out += "            data[i] = -v\n"
    out += "        else:\n"
    out += "            data[i] = v\n\n"
    return out

fn emit_for_dtype(buf: String, dtype: DTypeInfo) -> String:
    var sum_base = "mojor_sum_" + dtype.tag
    var out2 = emit_reduce(buf, sum_base, dtype, "REDUCE_SUM", False)
    out2 = emit_reduce(out2, sum_base + "_std", dtype, "REDUCE_SUM", False)
    out2 = emit_reduce(out2, sum_base + "_nomiss", dtype, "REDUCE_SUM", False)
    if dtype.tag == "f64":
        out2 = emit_reduce(out2, sum_base + "_nomiss_manual", dtype, "REDUCE_SUM", True)

    if dtype.tag == "f64":
        out2 = emit_abs_f64(out2)

    var reduce_names = ["prod", "min", "max", "mean"]
    var reduce_ops = ["REDUCE_PROD", "REDUCE_MIN", "REDUCE_MAX", "REDUCE_MEAN"]
    for i in range(len(reduce_names)):
        var name = "mojor_" + reduce_names[i] + "_" + dtype.tag
        out2 = emit_reduce(out2, name, dtype, reduce_ops[i], False)
        out2 = emit_reduce(out2, name + "_nomiss", dtype, reduce_ops[i], False)

    out2 = emit_which(out2, "mojor_which_min_" + dtype.tag + "_nomiss", dtype, True)
    out2 = emit_which(out2, "mojor_which_max_" + dtype.tag + "_nomiss", dtype, False)

    out2 = emit_sdvar(out2, "mojor_sd_" + dtype.tag + "_nomiss", dtype, False)
    out2 = emit_sdvar(out2, "mojor_sd_" + dtype.tag + "_nomiss_twopass", dtype, True)
    out2 = emit_sdvar(out2, "mojor_var_" + dtype.tag + "_nomiss", dtype, False)
    out2 = emit_sdvar(out2, "mojor_var_" + dtype.tag + "_nomiss_twopass", dtype, True)
    return out2

fn gen_reduce_block() -> String:
    var begin = "# BEGIN GENERATED REDUCE_EXPORTS"
    var end_marker = "# END GENERATED REDUCE_EXPORTS"
    var out = ""
    out += begin + "\n"
    out += "# NOTE: generated by tools/gen_reduce_exports.mojo\n"

    out = emit_for_dtype(out, DTypeInfo(tag="f64", dtype="DType.float64", ptr="ImmutF64Ptr", ret="Float64"))
    out = emit_for_dtype(out, DTypeInfo(tag="f32", dtype="DType.float32", ptr="ImmutF32Ptr", ret="Float32"))

    out += end_marker + "\n"
    return out


fn replace_block(text: String, begin: String, end_marker: String, block: String) -> String:
    var start = text.find(begin)
    var end = text.find(end_marker)
    if start < 0 or end < 0 or end < start:
        return text
    var pre = text[0:start]
    var after = text[end + len(end_marker):]
    if after.startswith("\n"):
        after = after[1:]
    return pre + block + after


fn main():
    var args = argv()
    var path = "packages/mojor/src/backend.mojo"
    if len(args) > 1:
        path = String(args[1])

    try:
        var file = Path(path)
        var text = file.read_text()
        var block = gen_reduce_block()
        var updated = replace_block(text, "# BEGIN GENERATED REDUCE_EXPORTS", "# END GENERATED REDUCE_EXPORTS", block)
        if updated != text:
            file.write_text(updated)
            print("updated " + path)
        else:
            print("no changes needed")
    except:
        print("failed to update " + path)
